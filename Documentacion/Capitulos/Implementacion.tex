\subsection*{Estructura del Proyecto}

El proyecto está organizado en dos microservicios principales:

\begin{itemize}
    \item \textbf{centralservice} - Servicio de registro y coordinación
    \item \textbf{p2pnodo} - Nodos P2P para almacenamiento y distribución
\end{itemize}
\newpage
\subsection*{Servicio Central}

\subsubsection*{Modelos de Datos}

\textbf{NodeRegistration.java}
\begin{lstlisting}[language=Java]
public class NodeRegistration {
    private String nodeId;
    private String nodeUrl;
    private List<String> fragments;
    // getters y setters
}
\end{lstlisting}

\textbf{FragmentEvent.java}
\begin{lstlisting}[language=Java]
public class FragmentEvent {
    private String fragmentId;
    private String nodeUrl;
    private Long timestamp;
    
    public boolean isValid() {
        return fragmentId != null && !fragmentId.isEmpty() &&
               nodeUrl != null && !nodeUrl.isEmpty();
    }
}
\end{lstlisting}

\subsubsection*{Controladores REST}

El servicio central expone endpoints REST para:
\begin{itemize}
    \item Registro de nodos
    \item Consulta de nodos disponibles
    \item Localización de fragmentos específicos
    \item Actualización de inventarios de fragmentos
\end{itemize}

\subsection*{Nodos P2P}

\subsubsection*{Auto-registro}

Cada nodo se registra automáticamente al iniciar usando \texttt{@PostConstruct}:

\begin{lstlisting}[language=Java]
@PostConstruct
public void registerOnStartup() {
    NodeRegistration registration = new NodeRegistration();
    registration.setNodeId(System.getenv("HOSTNAME"));
    registration.setNodeUrl(NODE_URL);
    registration.setFragments(List.of());
    
    restTemplate.postForObject(
        CENTRAL_SERVICE_URL + "/api/register",
        registration,
        String.class
    );
}
\end{lstlisting}

\subsubsection*{Cliente de Comunicación P2P}

La clase \texttt{NodeClient} maneja la comunicación entre nodos:

\begin{itemize}
    \item \textbf{downloadFragment()} - Descarga fragmentos de otros nodos
    \item \textbf{uploadFragment()} - Envía fragmentos usando multipart/form-data
\end{itemize}

\subsection*{Gestión de Fragmentos}

Los fragmentos se almacenan como archivos binarios y se transfieren usando:
\begin{itemize}
    \item HTTP multipart para subida de archivos
    \item Streaming de bytes para descarga
    \item Validación de integridad mediante IDs únicos
\end{itemize}

\subsection*{Configuración con Docker}

El sistema utiliza Docker Compose para orquestación:

\begin{itemize}
    \item \textbf{Redis} - Base de datos y Pub/Sub
    \item \textbf{Central Service} - Un contenedor
    \item \textbf{P2P Nodes} - Múltiples contenedores escalables
\end{itemize}

\textbf{Comando de despliegue:}
\begin{lstlisting}[language=bash]
docker compose up -d --scale p2pnodo=3
\end{lstlisting}

\subsection*{Manejo de Errores y Logging}

El sistema implementa:
\begin{itemize}
    \item Manejo de excepciones en comunicaciones HTTP
    \item Validación de datos de entrada
    \item Timeouts configurables para operaciones de red
\end{itemize}